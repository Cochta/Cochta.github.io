<meta charset="utf-8" emacsmode="-*- markdown -*-">
<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/slate.css?">

**Head shot Blogpost and documentation**
Version 1.0

Introduction
==============================================================

This blog post primarily explains how I created "Head Shot" and how I implemented the rollback.

Head Shot is a small online game developed for the SAE Institute.

Head Shot is a "Head-soccer like" game, 2 players can shoot a ball and score goals with it.
A game lasts 1:30 minutes at the end of the time the player having the highest score wins.

The project was done in 1 month

![A match played in real conditions](ressourceRollback/HeadShot.mp4)

Goals
--------------------------------------------------------------

Make a realtime responsive online multiplayer game.

Implement a rollback engine.


Using
==============================================================

Head Shot uses:
- The raylib library to render and to play sounds.
- The Bark physics engine developped by myself to simulate the physics. 
- The Photon library for the netorking

Architecture
==============================================================

The main application handles the networking, the rollback, the game logic and the rendering.

The rollback engine has access to the current game and handles the confirm game.

![the architecture](ressourceRollback/architecture.png)


Game Logic
==============================================================

General
--------------------------------------------------------------

Instead of creating complex architecture for the game logic I decided to include all the needed elements into the game class directly.

It made my life a lot easier when I started implementing the rollback engine.

Here are some examples, the details are in the comments:

![All the data a player needs](ressourceRollback/player.png)

![All the data the ball needs](ressourceRollback/ball.png)

Inputs
--------------------------------------------------------------

To handle the inputs, I store them in a single byte using bit-shifting, it makes the input packets smaller to send them to the other player.

![The input namespace with the Input system and the FrameInput struct](ressourceRollback/inputs.png)

Then with some basic logic I process the inputs retrieved each frame.

![The conditions for a player to move depending on the inputs](ressourceRollback/inputProcess.png)

Copy method
--------------------------------------------------------------

For the rollback to work properly I have to copy the confirm game state into the current game state before doing a rollback.

To ensure that all needed data is copied properly I copy it manually.

Because the contact listener handles a pointer to the logic I have to set it again each time, otherwise it makes the game non deterministic for both players. 

![The Copy method](ressourceRollback/copy.png)

Networking
==============================================================

![The networking is handled using the photon library](ressourceRollback/photon.png)

I overrided all the needed functions from the photon lib, here I will show the ones that I use for the netcode of the game.

ReceiveEvent
--------------------------------------------------------------
When a client received a packet, it stores it in a queue.

Then, at the start of a frame the client loops throught all the packets, handles them and pops them.

![The ReceiveEvent method](ressourceRollback/receiveEvent.png)

joinRoomEventAction
--------------------------------------------------------------

When the first player joins a room (rooms are entirely handled by photon), his id is set to 0.

When the second player joins a room, his id is set to 1, the game can start for both player and the rollback engine is setup aswell. 

![The joinRoomEventAction method](ressourceRollback/joinRoom.png)

Rollback engine
==============================================================

Rollback
--------------------------------------------------------------

Confirm frame
--------------------------------------------------------------

Rendering
==============================================================

I thought that making the game playable in a web browser could be a good idea,
that is why i chose raylib to render my game because it is compatible with empscripten and seamed easy to use.

The web build still needs to be done.

Conclusion
==============================================================

Thank you for reading so far !!!
==============================================================
I honestly hope, you enjoyed it :)


See Also
==============================================================

[My GitHub page](https://github.com/Cochta).

[My Itch.io page](https://cochta.itch.io).


<style class="fallback">body {
    visibility: hidden
}</style>
<script>markdeepOptions = {tocStyle: 'long'};</script>
<!-- Markdeep: -->
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
